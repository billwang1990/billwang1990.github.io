<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[亚庆的 Blog]]></title>
  <link href="http://billwang1990.github.io/atom.xml" rel="self"/>
  <link href="http://billwang1990.github.io/"/>
  <updated>2014-01-29T15:28:30+08:00</updated>
  <id>http://billwang1990.github.io/</id>
  <author>
    <name><![CDATA[王亚庆]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Mach-O Excutables]]></title>
    <link href="http://billwang1990.github.io/blog/2014/01/29/mach-o-excutable/"/>
    <updated>2014-01-29T14:40:15+08:00</updated>
    <id>http://billwang1990.github.io/blog/2014/01/29/mach-o-excutable</id>
    <content type="html"><![CDATA[<p>当我们使用xcode开发程序的时候，源文件（<em>.h </em>.m）会被编译成可执行文件。那么这一切到底是怎样发生的呢？下面来简单说明。</p>

<!--more-->


<h4>xcrun</h4>

<p>xrun是我们使用最多的一个命令行工具，这个小工具是用来运行别的工具的，比如：</p>

<pre><code>% clang -v
</code></pre>

<p>在命令行中，我们可以使用如下命令来代替上面的：</p>

<pre><code>% xcrun clang -v
</code></pre>

<p>xcrun将会指定clang然后传递后面的参数给它来运行。</p>

<h4>不用IDE来运行hello world</h4>

<p>回到命令行中，我们创建一个文件夹并生成一个C源文件。</p>

<pre><code>% mkdir ~/Desktop/objcio-command-line
% cd !$
% touch helloworld.c
</code></pre>

<p>接下来打开生成的C文件</p>

<pre><code>% open -e helloworld.c
</code></pre>

<p>编辑它：</p>

<pre><code>#include &lt;stdio.h&gt;
int main(int argc, char *argv[])
{
    printf("Hello World!\n");
    return 0;
}
</code></pre>

<p>保存后编译运行：</p>

<pre><code>% xcrun clang helloworld.c
% ./a.out
</code></pre>

<p>这个时候命令行就会输出你熟悉的Hello World了，整个过程都在命令行完成。</p>

<p>在刚才的过程中，我们将helloworld.c编译成一个Mach-O的可目标文件被称作a.out。</p>

<h4>Hello World and the Compiler</h4>

<p>我们使用的编译器是clang。</p>

<p>简单来说，编译器会将源文件生成可执行文件，这个过程由一系列步骤组成。</p>

<h4>预处理</h4>

<ul>
<li><code>Tokenization</code></li>
<li><code>Macro expansion</code></li>
<li><code>#include expansion</code></li>
</ul>


<h4>语义分析</h4>

<ul>
<li><code>Translates preprocessor tokens into a parse tree</code></li>
<li><code>Applies semantic analysis to the parse tree</code></li>
<li><code>Outputs an Abstract Syntax Tree (AST)</code></li>
</ul>


<h4>生成代码并优化</h4>

<ul>
<li><code>Translates an AST into low-level intermediate code (LLVM IR)</code></li>
<li><code>Responsible for optimizing the generated code</code></li>
<li><code>target-specific code generation</code></li>
<li><code>Outputs assembly</code></li>
</ul>


<h4>汇编</h4>

<ul>
<li><code>Translates assembly code into a target object file</code></li>
</ul>


<h4>链接</h4>

<ul>
<li><code>Merges multiple object files into an executable (or a dynamic library)</code></li>
</ul>


<p>简单的记录了一下几个步骤，更多详细的内容请查看<a href="http://www.objc.io/issue-6/mach-o-executables.html">这篇文章</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[GCD（Grand Central Dispatch）]]></title>
    <link href="http://billwang1990.github.io/blog/2014/01/13/grand-central-dispatch/"/>
    <updated>2014-01-13T11:12:04+08:00</updated>
    <id>http://billwang1990.github.io/blog/2014/01/13/grand-central-dispatch</id>
    <content type="html"><![CDATA[<h3>什么是GCD</h3>

<p>Grand Central Dispatch是异步执行任务的技术之一。开发者只需要定义想执行的任务追加到Dispatch Queue中，GCD就能生成必要的线程并计划执行任务。由于线程管理是作为系统的一部分来实现的，因此可统一管理，也可执行任务，这样就比以前的线程更有效率。</p>

<!--more-->


<h3>两种Dispatch Queue</h3>

<p>1、Serial Dispatch Queue
串行执行</p>

<p>2、Concurrent Dispatch Queue
并行执行，但并行执行的处理数量取决于当前系统的状态</p>

<h3>如何获取Dispatch Queue</h3>

<ol>
<li><p>通过dispatch_queue_create函数生成。
 可以生成任意多个queue，当生成多个serail queue的时候，多个serail queue将并行执行。虽然可以生成多个串行的queue来并行操作，但是系统对于一个serail queue就只生成一个线程，如果过多使用多线程，就会消耗大量内存，引起大量上下文切换，大幅度降低系统的响应性能。
 另外，生成的queue必须由程序员手动释放，使用dispatch_release函数。
 另外有下面一段代码需要注意：</p>

<pre><code> dispatch_queue_t myQueue = dispatch_queue_create(nil, DISPATCH_QUEUE_CONCURRENT);
 dispatch_async(queue, ^{NSLog(@"block on my queue");});
 dispatch_release(myQueue);
</code></pre>

<p> 在以上代码中，将block追加到queue，并立即release掉，这样做完全没有问题，在dispatch_async函数中追加block到queue，该block通过dispatch_retain函数持有queue，block结束时，会通过dispatch_release释放掉该block持有的queue。</p></li>
<li><p>获取系统标准提供的Dispatch Queue</p>

<p> Main Dispatch Queue(serail queue)和Global Dispatch Queue(Concurrent)</p>

<p> 另外Global Dispatch Queue有四个优先级。High Priority, Default Priority, Low Priority, Background Priority。
 对Main Dispatch Queue和Global Dispatch Queue执行release和retain没有任何变化</p></li>
</ol>


<h3>相关操作</h3>

<ol>
<li><p>dispatch_set_target_queue函数</p>

<p> dispatch_queue_create生成的queue都使用与默认优先级Global Disptch Queue相同执行优先级的线程，可以通过此函数变更优先级。</p></li>
<li><p>dispatch_after函数</p>

<p> <strong>它并不是在指定的时间后执行处理，而是在指定的事件后追加处理到Dispatch Queue。</strong></p></li>
<li><p>Dispatch Group</p>

<p> 可以实现追加到Dispatch Queue的多个处理全部结束后才追加某个操作。</p></li>
<li><p>dispatch_barrier_async函数</p>

<p> 它会等待追加到Concurrent Dispatch Queue上的并行执行的处理全部结束后，再将指定的处理追加到该queue中。</p></li>
<li><p>dispatch_sync</p>

<p> 和dispatch_async相反，此函数会等待追加的block执行操作直到其完成。</p></li>
</ol>


<h3>Dispatch Source</h3>

<p>关于这一部分，由于本人没真正使用过，所以简单的做个介绍。</p>

<p>GCD中除了Disptch Queue以外，还有个Dispatch Source，它是BSD系统内核惯有功能kqueue的包装。</p>

<p>kqueue是在XNU内核中发生各种事件时，在应用程序编程方执行处理的技术。其CPU负荷相当小，尽量不占用资源。</p>

<p>（尊重作者劳动成功，转载请注明出处）</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何写podspec贡献自己的代码到cocoapods]]></title>
    <link href="http://billwang1990.github.io/blog/2014/01/06/how-to-write-cocoapods-spec-file/"/>
    <updated>2014-01-06T19:27:37+08:00</updated>
    <id>http://billwang1990.github.io/blog/2014/01/06/how-to-write-cocoapods-spec-file</id>
    <content type="html"><![CDATA[<!--more-->


<h4>什么是cocoapods？</h4>

<p>做iOS开发需要用到很多三方，才开始可能很多人和我才开始一样，手动添加三方，费事费力。用了cocoapods之后，一切都变得so easy。如果还没用的同学请参考这篇<a href="http://blog.devtang.com/blog/2012/12/02/use-cocoapod-to-manage-ios-lib-dependency">大牛的介绍文章</a>。今天我要讲的是另外一个主题。</p>

<h4>贡献代码到cocoapods</h4>

<p>cocoapods是托管在<a href="https://github.com/cocoapods/cocoapods">github</a>上的一个开源项目，要想为它做贡献，首先你要会使用git，所以如果还不会的话，请先自学下吧。</p>

<p>所有的spec都在<a href="https://github.com/CocoaPods/Specs">这里</a>,你首先要做的是需要<strong>Fork</strong>这个仓库，然后你就拥有了一个仓库的副本，这个时候在自己的dashboard就就可以看到多了一个repo，接下来以我自己为例子把repo克隆下来。</p>

<pre><code>git clone https://github.com/billwang1990/Specs.git
</code></pre>

<p>克隆好了之后，就可以向里面添加自己的代码来，首先创建了一个文件夹。</p>

<pre><code>cd Specs/
mkdir yourDirName
cd yourDirName
</code></pre>

<p>这个时候先暂停下，对你要贡献的代码打个<strong>tag</strong></p>

<pre><code>git tag 0.0.1
</code></pre>

<p>然后,把tag推到你的项目的远程服务器端。</p>

<pre><code>git push --tags
</code></pre>

<p>接下来再回到之前在spec里创建的那个文件夹（yourDirName）中
再创建一个文件夹,并且生成一个spec文件</p>

<pre><code>mkdir 0.0.1
cd 0.0.1
pod spec create yourSpecFileName
</code></pre>

<p>这个时候你应该可以看到你的0.0.1文件夹多了一个yourSpecFileName.podspec文件，打开这个文件进行编辑吧。下面的就是我的podspec文件：</p>

<pre><code>Pod::Spec.new do |s|
     s.name         = "YQUpdateHelper"
     s.version      = "0.1.0"
     s.summary      = "YQUpdateHelper is an iOS toolkit, it can notify user if there is an new version of your app in app store."
     s.homepage     = "https://github.com/billwang1990/YQUpdateNotification"
     s.screenshots  = "https://github.com/billwang1990/YQUpdateNotification/blob/master/screenshot.PNG"
     s.license      = 'MIT (LICENSE)'
     s.author       = { "billwang1990" =&gt; "billwang1990@gmail.com" }
     s.platform     = :ios, '6.0'
      s.source       = { :git =&gt; "https://github.com/billwang1990/YQUpdateNotification.git", :tag =&gt; "0.1.0" }
       s.source_files  = 'YQUpdateHelper', 'YQUpdateHelper/*.{h,m}'
      s.resource  = "YQUpdateHelper/YQUpdateHelper.bundle"
     s.framework  = 'Foundation'
     s.requires_arc = true
end
</code></pre>

<p>OK,写完了保存，还没完事，你需要执行 <em>pod spec lint yourSpecFileName.podspec</em>检查一下你的文件内容是否写对了。</p>

<p>完事之后，你把仓库push到自己的远端，然后 <strong>send pull request</strong>，等待cocoapods团队merge了之后，你使用<strong>pod search</strong>就应该能找到你的代码了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于swizzling]]></title>
    <link href="http://billwang1990.github.io/blog/2014/01/04/about-swizzling/"/>
    <updated>2014-01-04T12:07:36+08:00</updated>
    <id>http://billwang1990.github.io/blog/2014/01/04/about-swizzling</id>
    <content type="html"><![CDATA[<!--more-->


<p><em>（尊重作者劳动成果，转载请注明出处）</em></p>

<p>今天在调试app的时候发现一个很奇怪的问题，我自定义的tableviewcell，使用了autolayout。在我的ipad（iOS7）上跑的时候一切正常。但是使用模拟器跑iOS6的系统的时候，抛出了一个异常：</p>

<pre><code>*** Terminating app due to uncaught exception 'NSInternalInconsistencyException', reason: 'Auto Layout still required after executing -layoutSubviews. UITableView's implementation of -layoutSubviews needs to call super.'
</code></pre>

<p>上网查资料，在stackoverflow上面有关于这个问题的讨论，貌似这个是iOS存在的一个bug，在iOS7已经解决了，在iOS6下使用autolayout的时候，可以通过swizzling（方法混写）来解决这个问题，本文的重点也是在swzzling上。</p>

<h4>什么是swizzling</h4>

<p>简单来说，swizzling可以动态的改变方法的实现，达到修改类的行为的目的。能够实现这一点，归功于objective-c的动态语言特性。</p>

<p>在iOS中，所有的方法并不是在编译的时候确定下来的，而是通过send message，runtime通过方法签名去查找方法的实现，再调用实现函数。因此也就给了大家机会在运行时动态的改变方法的实现代码。</p>

<p>我们可以在分类中实现swizzling，这里有一个关于分类中实现swizzling时机的选择，很多人的是在分类的<em>+load</em>方法中实现的swizzling，而<em>《ios 6 pushing the limits》</em>的作者在其书中阐述了他的观点，他认为方法混写可能会引发出人意料的行为。在+load中实现意味着只要链接分类便会自动启用方法混写。这可能会导致一些很难调试的bug。
话虽如此，我还是在+load方法中实现的swizzling。
（注：+load方法是一个钩子，它会在第一次加载分类的时候执行，如果多个分类都实现了+load，那么都会被调用）</p>

<p>OK,上代码说事，下面就是使用代码混写的解决方式：</p>

<pre><code>+ (void)load
{
    static dispatch_once_t onceToken;
    dispatch_once(&amp;onceToken, ^{

        SEL layoutSubviews = @selector(layoutSubviews);
        SEL replaceLayoutSubviews = @selector(_autolayout_replacementLayoutSubviews);

       Method existingMethod = class_getInstanceMethod(self, @selector(layoutSubviews));
        Method newMethod = class_getInstanceMethod(self, @selector(_autolayout_replacementLayoutSubviews));

        BOOL methodAdded = class_addMethod([self class], layoutSubviews, method_getImplementation(newMethod), method_getTypeEncoding(newMethod));

        if (methodAdded) {
            class_replaceMethod([self class],
                            replaceLayoutSubviews,
                          method_getImplementation(existingMethod),
                            method_getTypeEncoding(existingMethod));
        } else {
            method_exchangeImplementations(existingMethod, newMethod);
        }

    });
}

- (void)_autolayout_replacementLayoutSubviews
{
    [super layoutSubviews];
    [self _autolayout_replacementLayoutSubviews]; 
    [super layoutSubviews];
}
</code></pre>

<p>在+load方法中，先获取将要被代替的selector和代替它的selelctor，然后分别获取他们的Method，接着尝试把第二个方法的实现加在第一个方法的selector下，这么做的原因是防止第一个方法不存在。如果被成功加进去，那么也就是说第一个方法是空的，便把它替换了。如果bool值是NO，那么就需要将两者进行交换。</p>

<p>这里大家可能发现了在实现代码中有一句<em>[self _autolayout_replacementLayoutSubviews];</em>，这里并不会造成循环引用，因为在调用这个方法的时候已经通过swizzling将它交换了，这个时候你调用的是原来的实现函数。</p>

<p>大概总结了就这么多，如果又不对的地方，欢迎指正！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Text Kit的简单介绍]]></title>
    <link href="http://billwang1990.github.io/blog/2014/01/04/textkit/"/>
    <updated>2014-01-04T05:20:44+08:00</updated>
    <id>http://billwang1990.github.io/blog/2014/01/04/textkit</id>
    <content type="html"><![CDATA[<!--more-->


<h3>Text Kit的前世今生</h3>

<p>在iOS6以前，如果要渲染富文本的内容，可能通常会使用webview来实现，到了iOS6时增加了attribute string来支持这部分工作。</p>

<p>在iOS6中，基于文本的控件（比如UITextview，UILabel等）是基于Webkit和Core Graphic的绘图函数来实现的。</p>

<p>到了iOS7事件就变得不一样了，这些文本类型的控件是构建与Text Kit之上的了，不再是Web Kit.</p>

<p>Text Kit包含了以下的新功能：</p>

<ol>
<li>Dynamic type</li>
<li>Letterpress effects</li>
<li>Exclusion paths</li>
<li>Dynamic text formatting and storage</li>
</ol>


<h4>Dynamic type</h4>

<p>iOS7增强了灵活改变文字大小的功能，讲这个，你可以首先打开你的设备，在设置->通用->文字大小，你会发现可以改变阅读文字的大小，所有支持Dynamic type的App的字体都将和这里设置的字体保持一致。</p>

<p>要使你的App支持这一新功能，你只需要像下面一样设置你的字体：</p>

<pre><code>UIFont *font = [UIFont preferredFontForTextStyle:UIFontTextStyleBody];
</code></pre>

<p>是不是很简单，另外有一点，如果你想你的App随着你的设置菜单设置的字体大小改变的话，你还需要将注册到NSNotificationCenter来监听字体大小改变的事件。</p>

<h4>Letterpress effects</h4>

<p>要设置字体具有印刷效果比较简单的做法是给attribute string增加一个键NSTextEffectAttributeName，它的值为NSTextEffectLetterpressStyle。</p>

<h4>Exclusion paths</h4>

<p>利用这个功能，你可以让你的文字包围在一个图片的周围，让你的排版看起来更加的酷。
比如你有一个UITextView的instance，那么你要让它包围在你指定的一块区域的周围，你就可以可以用下面的方法：</p>

<pre><code>_textView.textContainer.exclusionPaths = @[your exclusionPath];
</code></pre>

<p>在这段代码中你可能发现了textContainer这么个属性，这也是很重要的一个东西，下文会提到的。</p>

<h4>Dynamic text formatting and storage</h4>

<p>利用Text Kit你不仅可以根据设置信息动态的改变字体的大小，而且你也可以利用它根据文本的内容动态的改变文字。</p>

<p>这里有三个东西需要注意：</p>

<ol>
<li><p>NSTextStorage：
它用来存储将要渲染的文字并通知 <em>layoutmanager</em> 关于文本内容的改变。</p></li>
<li><p>NSLayoutManager：
将存储的文本内容渲染到屏幕上。</p></li>
<li><p>NSTextContainer：
描述文本渲染的区域，如上文中，每一个UITextview的实例已经包含了一个<em>textContainer</em>了。</p></li>
</ol>


<p>个人认为这三者的关系正好符合MVC的结构，NSTextStorage扮演了model，NSLayoutManager扮演的是controller，而NSTextContainer扮演的是view。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS7 新的值类型 Instancetype]]></title>
    <link href="http://billwang1990.github.io/blog/2014/01/03/new-return-type-instancetype/"/>
    <updated>2014-01-03T09:01:56+08:00</updated>
    <id>http://billwang1990.github.io/blog/2014/01/03/new-return-type-instancetype</id>
    <content type="html"><![CDATA[<p>随着新的xcode和iOS7发布，iOS新增了一个类型instancetype. 但是它只能被用作返回值的类型，提示编译器方法的返回值的类型和调用此方法的类一致。<!--more-->
<code>注意：这并不是iOS7或者xcode5的特性，而是Clang中加入的</code></p>

<h4>为什么需要instancetype</h4>

<p>考虑下面一段代码￼￼￼￼</p>

<pre><code>NSDictionary *d = [NSArray arrayWithObjects:@(1), @(2), nil]; NSLog(@"%i", d.count);
</code></pre>

<p>很明显，这里面有个错误，但是编译器并不会提示你，不信你可以试试。这段代码甚至可以运行，因为NSDictionary和NSArray中都有count这个属性。</p>

<p>能够运行的原因是因为runtime的魔力，Obj-c的动态特性。runtime找到了count，因此编译器认为它是正确的。但是，如果你调用的是别的方法，那些在NSDictionary中并不存在的方法，比如objectAtIndex:，它会立刻指出问题的所在。</p>

<p>那么为什么编译器没有指出 +[NSArray arrayWithObjects::]返回的类型并不是NSDictionary类型的呢？请看代码：</p>

<pre><code>+ (id)arrayWithObjects:(id)firstObj, ...;
</code></pre>

<p>看到了么，返回值是id，意味着可以是任何Objective-C的对象。所以，编译器不会告诉你说“你错了！”。</p>

<p>那么为什么返回值要设置为id。因为这样你就可以写出你自己的子类而不回发生任何的问题。比如你创建一个继承自NSArray的子类</p>

<pre><code>@interface MyArray : NSArray
@end
</code></pre>

<p>现在你可以这样使用你的MYArray</p>

<pre><code>MyArray *array = [MyArray arrayWithObjects:@(1), @(2), nil];
</code></pre>

<p>如果你的类方法的返回值不是id类型的话，你需要对子类进行类型转换。于是引入了新的关键字 <em>instancetype</em>。</p>

<p>如果你查看iOS7的SDK你会发现关于这个方法的申明已经变成了下面的样子：</p>

<pre><code>+ (instancetype)arrayWithObjects:(id)firstObj, ...;
</code></pre>

<p>不同之处就是返回值类型变得不同了，新的返回类型告诉编译器说返回值将是与调用这个方法的类相同。那么，当<em>NSArray</em>调用 <em>arrayWithObejects:</em>时，编译器就知道了它的返回值是<em>NSArray</em>类型的。如果是由<em>MYArray</em>调用的，那么返回值的类型就是<em>MYArray</em>。</p>

<p>那么我们最初的代码，也就是给 <em>NSDictionary</em> <em>*d</em>赋值的那段代码，在使用xcode5编译的时候，它就会警告你说你错了，是不是感觉很棒？</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于NSRunloop的学习和理解]]></title>
    <link href="http://billwang1990.github.io/blog/2013/12/30/nsrunloop-issue/"/>
    <updated>2013-12-30T02:49:38+08:00</updated>
    <id>http://billwang1990.github.io/blog/2013/12/30/nsrunloop-issue</id>
    <content type="html"><![CDATA[<h4>NSRunloop是iOS中比较重要的一个东西，有必要对它进行学习理解之后做一些记录：</h4>

<!-- more -->


<p><strong>请尊重作者劳动成果，转载请注明出处！</strong></p>

<p>首先来看看苹果官方给出的解释：
<em>The NSRunLoop class declares the programmatic interface to objects that manage input sources. An NSRunLoop object processes input for sources such as mouse and keyboard events from the window system, NSPort objects, and NSConnection objects. An NSRunLoop object also processes NSTimer events.</em></p>

<p>在程序中，每个<em>NSThread</em>对象，包括了<em>main thread</em>都会有一个自动创建的<em>NSRunloop</em>对象如果需要的话。如果你想要获取当前线程的runloop的话，只需要调用 <em>currentRunloop</em>.</p>

<p>每个runloop可以运行在不同的模式之下，不同的runloop mode处理其mode下包含的input sources.</p>

<p>查看苹果Docunment可以看到，它通过两个常量定义了两个run loop mode:
1.extern NSString* const NSDefaultRunLoopMode;
在这个模式下，将会处理除了NSConnection以外的input source.这是最常用的run loop mode。</p>

<p>2.extern NSString* const NSRunLoopCommonModes;
这是一个run loop mode 的合集，将input source加入之后意味着在common mode包含的所有模式下都可以处理，在Cocoa应用程序中，默认情况下Common Modes包含default modes,modal modes,event Tracking modes.注意这个并不是一个特定的mode，而是一个mode的集合，而runloop必须运行在一个特定的mode下。</p>

<p>以上两个是由NSRunloop定义的，在文档中有句话，<em>Additional run loop modes are defined by NSConnection and NSApplication</em>，增加的三个mode就是下面这三个:</p>

<p>*NSConnectionReplyMode
这个mode表明NSConnection对象等待reply，通常不会用到。</p>

<p>*NSModalPanelRunLoopMode
需要等待处理的input source为modal panel时设置，比如NSSavePanel和NSOpenPanel。</p>

<p>*NSEventTrackingRunLoopMode
Cocoa使用该模式来处理用户界面相关的事件。</p>

<p>NSRunloop并不真的是一个loop，的apple的<a href="https://developer.apple.com/library/ios/documentation/cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html">文档中</a>
也提到了需要自己写while或者for语句来实现,类似下面：</p>

<pre><code>while(running){ 
    [NSRunLoop currentRunLoop]     runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];
}
</code></pre>

<h4>何为Run loop 事件源</h4>

<p>从字面翻译来看，run loop就是一个运行循环，的确它就是一个处理输入时间的运行循环，为什么需要这样处理，难道没有事件发生的时候让线程空转浪费资源？很明显在有事件发生的时候唤醒线程，没有事件发生的时候让其sleep更好。</p>

<p>下面我还是拿这张百看不厌的图来说事：</p>

<p><img src="https://developer.apple.com/library/mac/documentation/cocoa/conceptual/Multithreading/Art/runloop.jpg" alt="alt text" /></p>

<p>可以看到，runloop处理的source大体上分为两种，一种是input source 还有一种是time source.</p>

<p>1.Time Source.
Timer sources deliver synchronous events, occurring at a scheduled time or repeating interval.</p>

<p>苹果文档中有句话需要注意，<code>Timer sources deliver events to their handler routines but do not cause the run loop to exit.</code></p>

<p>创建NSTimer添加到run loop中的时候，这里需要注意的是，NSTimer默认是处于NSDefaultRunloopMode，这也就可以解释为什么如果你在你的控制器中添加了一个timer定时刷新你的界面，而你在拖动视图的时候timer不回fire，因为这个时候你的runloop 是NSEventTrackingRunloopMode,在这个mode下timer不回fire。</p>

<p>2.input source
input source 主要是一些异步的事件，比如来自其它线程或者其它app的消息。</p>

<p>input source 传递异步事件到其对应的处理函数，并且使<code>runUntilDate</code>(与线程相关联的runloop对象调用)返回。</p>

<p>为了能够处理input sourcr，run loops 产生notifications.通过注册成run-loop observers可以接受到这些通知（通过Core Foundation 来注册observers）.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS 开发设计模式笔记（3）]]></title>
    <link href="http://billwang1990.github.io/blog/2013/12/27/12-dot-27/"/>
    <updated>2013-12-27T21:16:21+08:00</updated>
    <id>http://billwang1990.github.io/blog/2013/12/27/12-dot-27</id>
    <content type="html"><![CDATA[<p><strong>8.外观模式</strong></p>

<pre><code> 定义：为系统中的一组接口提供一个统一的接口，外观定义一个高层接口，让子系统更易于使用。

 适用情形：
 子系统正逐渐变得复杂。应用模式的过程中演化出很多类。可以适用外观为这些子系统提供一个比较简单的接口。
 可以使用外观对子系统进行分层。每个子系统级别由一个外观作为入口点。让他们通过其外观进行通信，可以简化它们的依赖关系。
</code></pre>

<!-- more -->


<p><strong>9.中介者模式</strong></p>

<pre><code> 定义：用一个对象来封装一系列对象的交互方式。中介者使各对象不需要显示地相互引用，从而使其耦合松散，而且可以独立地改变他们之间的交互。

 适用情形：
 对象间的交互虽然定义明确然而非常复杂，导致一组对象彼此相互依赖而且难以理解。
 因为对象引用了许多其他对象并与其通讯，导致对象难以复用。
 想要定制一个分布在多个类中的逻辑或行为，又不想由太多子类。

 ”迪米特法则“，如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中的一个类需要调用另一个累的某一个方法的话，可以通过第三者转发。

 说明：中介者模式以中介者内部的复杂性代替交互的复杂性，因为中介者封装与合并了colleague的各种协作逻辑，自身可能变得比他们任何一个都要复杂得多，这会让中介者本身变成无所不知的庞然大物，并且难以维护。
</code></pre>

<p><strong>10.观察者模式</strong></p>

<pre><code> 定义：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动更新。
 也称作发布——订阅模式。

 适用情形：
 有两种抽象类型相互依赖。将他们封装在各自的对象中，就可以对他们单独进行改变和复用。
 对一个对象的改变需要同时改变其他对象，但是又不知道有多少对象待改变。
 一个对象必须通知其它对象，但是又不知道其他对象是什么。
</code></pre>

<p><strong>11.组合模式</strong></p>

<pre><code> 定义：将对象组合成树形结构以表示“部分——整体”的层次结构，组合使得用户对单个对象和组合对象的使用具有一致性。

 适用情形：
 想获得对象抽象的树形表示（部分——整体层次结构）
 想让客户端统一处理组合结构中的所有对象。
</code></pre>

<p><strong>12.迭代器模式</strong></p>

<pre><code> 定义：提供一种方法访问一个聚合对象中的各个元素，而又不暴露对该对象的内部表示。

 基本上由两种类型的迭代器：外部迭代器和内部迭代器。外部迭代器让客户端直接操作迭代过程，所以客户端需要知道外部迭代器才能使用。另一种情况是，集合对象在其内部维护并操作一个外部迭代器。提供内部迭代器的典型的集合对象为客户端定义一个接口，或者从底层的集合一次访问一个元素，或者向每个元素发送消息。
 适用情形：
 需要访问组合对象的内容，而又不暴露其内部表示。。
 需要通过多种方式遍历组合对象。
 需要提供一个统一的接口，用来遍历各种类型的组合对象。
</code></pre>

<p><strong>13.访问者模式</strong></p>

<pre><code> 定义：表示一个作用于某对象结构中的各元素的操作。它让我们可以在不改变各元素的类的前提下定义作用于这些元素的新操作。

 适用情形：
 一个复杂的对象结构包含很多其他对象，他们有不同的接口，但是想对这些对象实施一些依赖于其具体类型的操作。
 需要对一个组合结构的对象进行很多不相关的操作，但是不想让这些操作”污染“这些对象的类。可以将相关的操作集中起来，定义在一个访问者类中，并在需要在访问者中定义的操作时使用它。
 定义复杂结构的类很少做修改，但是需要经常向其添加新的操作。
</code></pre>

<p><strong>14.装饰模式</strong></p>

<pre><code> 定义：动态地给一个对象添加一些额外地职责。就扩展功能来说，装饰模式相比生成子类更为灵活。

 适用情形：
 想要在不影响其他对象的情况下，以动态、透明的方式给单个对象加职责。
 想要扩展一个类的行为，却做不到。类定义可能被隐藏，无法进行子类化；或者，对类的每个行为的扩展，为支持每种功能组合，将产生大量的子类。
 对类的职责的扩展是可选的。
</code></pre>

<p><strong>15.责任链者模式</strong></p>

<pre><code> 责任链模式的主要思想是，对象引用了同一类型的另一个对象，形成一条链。链中的每个对象实现了同样的方法，处理链中第一个对象发起的同一个请求。如果一个对象不知道如何处理请求，它就把请求传给下一个响应器。

 定义：使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间发生耦合，此模式将这些对象连成一条链，并沿着这条链传递请求，知道有一个对象处理它为止。

 适用情形：
 有多个对象可以处理请求，而处理程序只有在运行时才能确定。
 向一组对象发出请求，而不想显示地指定处理请求的特定处理程序。
</code></pre>

<p><strong>16.模板方法模式</strong></p>

<pre><code> 定义：定义一个操作中算法的骨架，而将一些步骤延迟到子类中。模板方法使子类可以重定义算法的某些特定步骤而不改变算法的结构。
</code></pre>

<p><strong>17.策略模式</strong></p>

<pre><code> 定义：定义一系列算法，把他们一个个封装起来，并且使他们可相互替换。本模式使得算法可独立于使用它的客户而变化。

 适用情形：
 一个类在其操作中适用多个条件语句来定义很多行为。我们可以把相关的条件分支移动到他们自己的策略类中。
 需要算法的各种变体。
 需要避免把复杂的、与算法相关的数据结构暴露给客户端。
</code></pre>

<p><strong>18.命令模式</strong></p>

<pre><code> 定义：将请求封装为一个对象，从而可用不同的请求对客户进行参数化，对请求排队或者记录请求日志，以及支持可撤销的操作。

 适用情形：
 想让应用程序支持撤销与恢复。
 想用对象参数化一个动作以执行操作，并用不同命令对象来代替回调函数。
 想要在不同时刻对请求进行指定、排列和执行。
 想记录修改日志，这样在系统故障时，这些修改可在后来重做一遍。
 想让系统支持事务，事务封装了对数据的一系列修改。事务可以建模为命令对象。
</code></pre>

<p><strong>19.Flyweight pattern 享元模式</strong></p>

<pre><code>适用场景：
 应用程序使用很多对象
 在内存中保存对象会影响性能
 对象的多数特有状态（外在状态）可以放到外部而轻量化
 移除了外在状态后，可以用较少的共享对象替代原来那组对象
 应用程序不依赖对象标识
节省内存
</code></pre>

<p><strong>20.代理模式</strong></p>

<pre><code> 定义：为其他对象提供一种代理以控制对这个对象的访问。

 适用情形：
 需要一个远程代理，为位于不同地址空间或者网络中的对象提供本地代表。
 需要一个虚拟代理，来根据要求创建重型的对象。
 需要一个保护代理，来根据不同访问权限控制对原对象的访问。
 需要一个智能引用代理，通过对实体对象的引用进行引用技术来管理内存。也能用于锁定实体对象，让其他对象不能改变
</code></pre>

<p><strong>21.备忘录模式</strong></p>

<pre><code> 定义：在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样以后就可将该对象恢复到原先保存的状态。

 适用情形：
 需要保存一个对象（或某部分）在某一时刻的状态，这样以后就可以恢复到先前的状态。
 用于捕获状态的接口会暴露实现的细节，需要将其隐藏起来。
</code></pre>

<p>写到这里，关于iOS设计模式的笔记就差不多写完了，可能有些地方不是太对，还望大家多多指点，给我发<a href="billwang1990@gmail.com">gmail</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MAC下安装Octopress，Cocoapods关于ruby版本的问题]]></title>
    <link href="http://billwang1990.github.io/blog/2013/12/26/3-number-post/"/>
    <updated>2013-12-26T06:01:54+08:00</updated>
    <id>http://billwang1990.github.io/blog/2013/12/26/3-number-post</id>
    <content type="html"><![CDATA[<p>不多说，直接上正题。
系统是10.8.4的，没升级，黑苹果不敢升级，每次升级会很麻烦！</p>

<p>因为开发iOS，所以需要使用cocoapods来管理三方, 另外需要搭建一个Octopress的blog，两者都需要用到ruby，问题来了：</p>

<p>Octopress要求ruby的版本不低于 1.9.3，而系统自带的ruby是1.8.7的，很明显不搭调，于是使用 <strong>rvm install 1.9.3</strong> 安装ruby。 然后照<a href="http://octopress.org/docs/setup/">Octopress官方安装教程</a>配置。</p>

<!-- more -->


<p>OK，Octopress一切完工，这个时候我来安装cocoapods，它也用到了ruby，这个时候默认的ruby已经不是系统自带的ruby了。于是在使用 <strong>$sudo gem install cocoapods</strong> 安装的时候一直报错 ：COreFoundation is needed to build the Xcodeproj C extension.</p>

<p>找了很多解决办法，比如重新安装xcode command line tools，使用xcode-selelct等等，都不起作用。好吧，最后还是去cocoapods看看，开发者强烈建议使用Mac自带的ruby来安装cocoapods。</p>

<p>好吧，最后我妥协了，将默认的ruby还原为系统自带的ruby，这个时候再来安装cocoapods，一切正常. 然后只是将octopress的工作目录使用rvm配置为使用1.9.3的ruby，也就是说使用了两个版本的ruby。</p>

<p>方法虽然看起来是土了一点，但是简单粗暴有效！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS 开发设计模式笔记（2）]]></title>
    <link href="http://billwang1990.github.io/blog/2013/12/25/2nd-blog/"/>
    <updated>2013-12-25T08:36:33+08:00</updated>
    <id>http://billwang1990.github.io/blog/2013/12/25/2nd-blog</id>
    <content type="html"><![CDATA[<p>这篇是接着<a href="http://billwang1990.github.io/blog/2013/12/25/1st-blog/">上一篇</a></p>

<h4>4.生成器模式</h4>

<pre><code> 定义：
 将一个复杂对象的构建与它的表现分离，使得同样的构建过程可以创建不同的表现。
 适用情景：
 需要创建涉及各种部件的复杂对象。创建对象的算法应该独立于部件的装配方式。常见例子是构建组合对象。
 构建过程需要以不同的方式构建对象。
 将做什么 和 怎么做 两个问题分开解决。
</code></pre>

<!-- more -->


<h4>5.单例模式</h4>

<pre><code> 定义:保证一个类仅有一个实例，并且提供一个访问它的全局访问点。
 适用情形:
 类只能有一个实例，而且必须从一个为人熟知的访问点对其进行访问，比如工厂方法。
 这个唯一的实例只能通过子类化进行扩展，而且扩展的对象不会破坏客户端代码。
</code></pre>

<h4>6.适配器模式</h4>

<pre><code> 适配器模式，用于连接两种不同种类的对象，使其毫无问题地协同工作，有时它也称为包装起"wrapper"。
 基本上有两种实现适配器的方式:
 1.通过集成来适配来适配两个接口，这种称为类适配器，多通过多重继承来实现，但是OBJ-C没有多重继承，可以通过协议来实现。
 2.对象适配器。与类适配器不同，对象适配器不继承被适配者，而是组合一个对它的引用。
 定义：
 将一个类的接口转换成客户希望的另一个接口，适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。
 适用情形：
 已有的类的接口和需求不匹配。
 想要一个可复用的类，该类能够同可能带有不兼容接口的其它类协作。
 需要适配一个类的几个不同子类，可是让每一个子类去子类化一个类适配器又不现实。那么可以通过使用对象适配器（也叫委托）来适配其父类的接口。
</code></pre>

<h4>7.桥接模式</h4>

<pre><code> 定义：将抽象部分与它的实现部分分离，使它们都可以独立的变化。
 适用情形：
 不想在抽象与其实现之间实现固定的绑定关系。
 抽象及其实现都应该可以通过子类化独立进行扩展。
 对抽象的实现进行修改不应该影响客户端的代码。
 如果每个实现需要额外的子类以细化抽象，择说明有必要把他们分成两个部分。
 想在带有不同抽象接口的多个对象之间共享一个实现。
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS 开发设计模式笔记（1）]]></title>
    <link href="http://billwang1990.github.io/blog/2013/12/25/1st-blog/"/>
    <updated>2013-12-25T07:52:44+08:00</updated>
    <id>http://billwang1990.github.io/blog/2013/12/25/1st-blog</id>
    <content type="html"><![CDATA[<h4>读了《OBJECTIVE－C编程之道 IOS设计模式解析》，觉得有些东西有必要记录下来,因此有了以下的笔记:</h4>

<h4>1.Prototype 原型模式</h4>

<pre><code>定义：使用原型实例指定创建对象的种类，并通过复制这个原型创建新的对象。（《设计模式》1994）
</code></pre>

<!-- more -->


<pre><code> 一般在初始化信息不发生变化的情况下，克隆是最好的办法。这既可以隐藏对象创建的细节，又对性能是大大的提升。
 适用情景：
 需要创建的对象应独立于其类型与创建方式。
 要实例化的类是运行时决定的。
 不想要与产品层次相对应的工厂层次。
 不同类的实例间的差异仅是状态的若干组合。因此复制相应数量的原型比手工实例化更加方便。
 类不容易创建，比如每个组件可把其他组件作为子节点的组合对象。复制已有的组合对象并对副本进行修改会更加容易。
</code></pre>

<h4>2.工厂方法模式</h4>

<pre><code> 工厂方法也称为虚构造器。它适用于这种情况：一个类无法预期需要生成哪个类的对象，想让其子类来指定所生成的对象。
 定义：定义创建对对象的接口，让子类决定实例化哪一个类，工厂方法使得一个类的实例化延迟到子类。
 适用情形：
 编译时无法准确预期要创建的对象的类。
 类想让其子类决定在运行时创建什么
 类由若干辅助类为其子类，而你想将返回哪个子类这一信息局部化
</code></pre>

<h4>3.抽象工厂</h4>

<pre><code>定义：提供一个创建一系列相关或相互依赖对象的接口，而无需指定他们具体的类。
 软件设计黄金法则：变动需要抽象。
 比如，如果APP要支持更换皮肤，可以设计成抽象工厂。
</code></pre>
]]></content>
  </entry>
  
</feed>
