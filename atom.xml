<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[亚庆的 Blog]]></title>
  <link href="http://billwang1990.github.io/atom.xml" rel="self"/>
  <link href="http://billwang1990.github.io/"/>
  <updated>2014-01-03T21:06:51-08:00</updated>
  <id>http://billwang1990.github.io/</id>
  <author>
    <name><![CDATA[王亚庆]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[关于swizzling]]></title>
    <link href="http://billwang1990.github.io/blog/2014/01/03/about-swizzling/"/>
    <updated>2014-01-03T20:07:36-08:00</updated>
    <id>http://billwang1990.github.io/blog/2014/01/03/about-swizzling</id>
    <content type="html"><![CDATA[<!--more-->


<p><em>（尊重作者劳动成果，转载请注明出处）</em></p>

<p>今天在调试app的时候发现一个很奇怪的问题，我自定义的tableviewcell，使用了autolayout。在我的ipad（iOS7）上跑的时候一切正常。但是使用模拟器跑iOS6的系统的时候，抛出了一个异常：</p>

<pre><code>*** Terminating app due to uncaught exception 'NSInternalInconsistencyException', reason: 'Auto Layout still required after executing -layoutSubviews. UITableView's implementation of -layoutSubviews needs to call super.'
</code></pre>

<p>上网查资料，在stackoverflow上面有关于这个问题的讨论，貌似这个是iOS存在的一个bug，在iOS7已经解决了，在iOS6下使用autolayout的时候，可以通过swizzling（方法混写）来解决这个问题，本文的重点也是在swzzling上。</p>

<h4>什么是swizzling</h4>

<p>简单来说，swizzling可以动态的改变方法的实现，达到修改类的行为的目的。能够实现这一点，归功于objective-c的动态语言特性。</p>

<p>在iOS中，所有的方法并不是在编译的时候确定下来的，而是通过send message，runtime通过方法签名去查找方法的实现，再调用实现函数。因此也就给了大家机会在运行时动态的改变方法的实现代码。</p>

<p>我们可以在分类中实现swizzling，这里有一个关于分类中实现swizzling时机的选择，很多人的是在分类的<em>+load</em>方法中实现的swizzling，而<em>《ios 6 pushing the limits》</em>的作者在其书中阐述了他的观点，他认为方法混写可能会引发出人意料的行为。在+load中实现意味着只要链接分类便会自动启用方法混写。这可能会导致一些很难调试的bug。
话虽如此，我还是在+load方法中实现的swizzling。
（注：+load方法是一个钩子，它会在第一次加载分类的时候执行，如果多个分类都实现了+load，那么都会被调用）</p>

<p>OK,上代码说事，下面就是使用代码混写的解决方式：</p>

<pre><code>+ (void)load
{
    static dispatch_once_t onceToken;
    dispatch_once(&amp;onceToken, ^{

        SEL layoutSubviews = @selector(layoutSubviews);
        SEL replaceLayoutSubviews = @selector(_autolayout_replacementLayoutSubviews);

       Method existingMethod = class_getInstanceMethod(self, @selector(layoutSubviews));
        Method newMethod = class_getInstanceMethod(self, @selector(_autolayout_replacementLayoutSubviews));

        BOOL methodAdded = class_addMethod([self class], layoutSubviews, method_getImplementation(newMethod), method_getTypeEncoding(newMethod));

        if (methodAdded) {
            class_replaceMethod([self class],
                            replaceLayoutSubviews,
                          method_getImplementation(existingMethod),
                            method_getTypeEncoding(existingMethod));
        } else {
            method_exchangeImplementations(existingMethod, newMethod);
        }

    });
}

- (void)_autolayout_replacementLayoutSubviews
{
    [super layoutSubviews];
    [self _autolayout_replacementLayoutSubviews]; 
    [super layoutSubviews];
}
</code></pre>

<p>在+load方法中，先获取将要被代替的selector和代替它的selelctor，然后分别获取他们的Method，接着尝试把第二个方法的实现加在第一个方法的selector下，这么做的原因是防止第一个方法不存在。如果被成功加进去，那么也就是说第一个方法是空的，便把它替换了。如果bool值是NO，那么就需要将两者进行交换。</p>

<p>这里大家可能发现了在实现代码中有一句<em>[self _autolayout_replacementLayoutSubviews];</em>，这里并不会造成循环引用，因为在调用这个方法的时候已经通过swizzling将它交换了，这个时候你调用的是原来的实现函数。</p>

<p>大概总结了就这么多，如果又不对的地方，欢迎指正！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Text Kit的简单介绍]]></title>
    <link href="http://billwang1990.github.io/blog/2014/01/03/textkit/"/>
    <updated>2014-01-03T13:20:44-08:00</updated>
    <id>http://billwang1990.github.io/blog/2014/01/03/textkit</id>
    <content type="html"><![CDATA[<!--more-->


<h3>Text Kit的前世今生</h3>

<p>在iOS6以前，如果要渲染富文本的内容，可能通常会使用webview来实现，到了iOS6时增加了attribute string来支持这部分工作。</p>

<p>在iOS6中，基于文本的控件（比如UITextview，UILabel等）是基于Webkit和Core Graphic的绘图函数来实现的。</p>

<p>到了iOS7事件就变得不一样了，这些文本类型的控件是构建与Text Kit之上的了，不再是Web Kit.</p>

<p>Text Kit包含了以下的新功能：</p>

<ol>
<li>Dynamic type</li>
<li>Letterpress effects</li>
<li>Exclusion paths</li>
<li>Dynamic text formatting and storage</li>
</ol>


<h4>Dynamic type</h4>

<p>iOS7增强了灵活改变文字大小的功能，讲这个，你可以首先打开你的设备，在设置->通用->文字大小，你会发现可以改变阅读文字的大小，所有支持Dynamic type的App的字体都将和这里设置的字体保持一致。</p>

<p>要使你的App支持这一新功能，你只需要像下面一样设置你的字体：</p>

<pre><code>UIFont *font = [UIFont preferredFontForTextStyle:UIFontTextStyleBody];
</code></pre>

<p>是不是很简单，另外有一点，如果你想你的App随着你的设置菜单设置的字体大小改变的话，你还需要将注册到NSNotificationCenter来监听字体大小改变的事件。</p>

<h4>Letterpress effects</h4>

<p>要设置字体具有印刷效果比较简单的做法是给attribute string增加一个键NSTextEffectAttributeName，它的值为NSTextEffectLetterpressStyle。</p>

<h4>Exclusion paths</h4>

<p>利用这个功能，你可以让你的文字包围在一个图片的周围，让你的排版看起来更加的酷。
比如你有一个UITextView的instance，那么你要让它包围在你指定的一块区域的周围，你就可以可以用下面的方法：</p>

<pre><code>_textView.textContainer.exclusionPaths = @[your exclusionPath];
</code></pre>

<p>在这段代码中你可能发现了textContainer这么个属性，这也是很重要的一个东西，下文会提到的。</p>

<h4>Dynamic text formatting and storage</h4>

<p>利用Text Kit你不仅可以根据设置信息动态的改变字体的大小，而且你也可以利用它根据文本的内容动态的改变文字。</p>

<p>这里有三个东西需要注意：</p>

<ol>
<li><p>NSTextStorage：
它用来存储将要渲染的文字并通知 <em>layoutmanager</em> 关于文本内容的改变。</p></li>
<li><p>NSLayoutManager：
将存储的文本内容渲染到屏幕上。</p></li>
<li><p>NSTextContainer：
描述文本渲染的区域，如上文中，每一个UITextview的实例已经包含了一个<em>textContainer</em>了。</p></li>
</ol>


<p>个人认为这三者的关系正好符合MVC的结构，NSTextStorage扮演了model，NSLayoutManager扮演的是controller，而NSTextContainer扮演的是view。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS7 新的值类型 Instancetype]]></title>
    <link href="http://billwang1990.github.io/blog/2014/01/02/new-return-type-instancetype/"/>
    <updated>2014-01-02T17:01:56-08:00</updated>
    <id>http://billwang1990.github.io/blog/2014/01/02/new-return-type-instancetype</id>
    <content type="html"><![CDATA[<p>随着新的xcode和iOS7发布，iOS新增了一个类型instancetype. 但是它只能被用作返回值的类型，提示编译器方法的返回值的类型和调用此方法的类一致。<!--more-->
<code>注意：这并不是iOS7或者xcode5的特性，而是Clang中加入的</code></p>

<h4>为什么需要instancetype</h4>

<p>考虑下面一段代码￼￼￼￼</p>

<pre><code>NSDictionary *d = [NSArray arrayWithObjects:@(1), @(2), nil]; NSLog(@"%i", d.count);
</code></pre>

<p>很明显，这里面有个错误，但是编译器并不会提示你，不信你可以试试。这段代码甚至可以运行，因为NSDictionary和NSArray中都有count这个属性。</p>

<p>能够运行的原因是因为runtime的魔力，Obj-c的动态特性。runtime找到了count，因此编译器认为它是正确的。但是，如果你调用的是别的方法，那些在NSDictionary中并不存在的方法，比如objectAtIndex:，它会立刻指出问题的所在。</p>

<p>那么为什么编译器没有指出 +[NSArray arrayWithObjects::]返回的类型并不是NSDictionary类型的呢？请看代码：</p>

<pre><code>+ (id)arrayWithObjects:(id)firstObj, ...;
</code></pre>

<p>看到了么，返回值是id，意味着可以是任何Objective-C的对象。所以，编译器不会告诉你说“你错了！”。</p>

<p>那么为什么返回值要设置为id。因为这样你就可以写出你自己的子类而不回发生任何的问题。比如你创建一个继承自NSArray的子类</p>

<pre><code>@interface MyArray : NSArray
@end
</code></pre>

<p>现在你可以这样使用你的MYArray</p>

<pre><code>MyArray *array = [MyArray arrayWithObjects:@(1), @(2), nil];
</code></pre>

<p>如果你的类方法的返回值不是id类型的话，你需要对子类进行类型转换。于是引入了新的关键字 <em>instancetype</em>。</p>

<p>如果你查看iOS7的SDK你会发现关于这个方法的申明已经变成了下面的样子：</p>

<pre><code>+ (instancetype)arrayWithObjects:(id)firstObj, ...;
</code></pre>

<p>不同之处就是返回值类型变得不同了，新的返回类型告诉编译器说返回值将是与调用这个方法的类相同。那么，当<em>NSArray</em>调用 <em>arrayWithObejects:</em>时，编译器就知道了它的返回值是<em>NSArray</em>类型的。如果是由<em>MYArray</em>调用的，那么返回值的类型就是<em>MYArray</em>。</p>

<p>那么我们最初的代码，也就是给 <em>NSDictionary</em> <em>*d</em>赋值的那段代码，在使用xcode5编译的时候，它就会警告你说你错了，是不是感觉很棒？</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于NSRunloop的学习和理解]]></title>
    <link href="http://billwang1990.github.io/blog/2013/12/29/nsrunloop-issue/"/>
    <updated>2013-12-29T10:49:38-08:00</updated>
    <id>http://billwang1990.github.io/blog/2013/12/29/nsrunloop-issue</id>
    <content type="html"><![CDATA[<h4>NSRunloop是iOS中比较重要的一个东西，有必要对它进行学习理解之后做一些记录：</h4>

<!-- more -->


<p><strong>请尊重作者劳动成果，转载请注明出处！</strong></p>

<p>首先来看看苹果官方给出的解释：
<em>The NSRunLoop class declares the programmatic interface to objects that manage input sources. An NSRunLoop object processes input for sources such as mouse and keyboard events from the window system, NSPort objects, and NSConnection objects. An NSRunLoop object also processes NSTimer events.</em></p>

<p>在程序中，每个<em>NSThread</em>对象，包括了<em>main thread</em>都会有一个自动创建的<em>NSRunloop</em>对象如果需要的话。如果你想要获取当前线程的runloop的话，只需要调用 <em>currentRunloop</em>.</p>

<p>每个runloop可以运行在不同的模式之下，不同的runloop mode处理其mode下包含的input sources.</p>

<p>查看苹果Docunment可以看到，它通过两个常量定义了两个run loop mode:
1.extern NSString* const NSDefaultRunLoopMode;
在这个模式下，将会处理除了NSConnection以外的input source.这是最常用的run loop mode。</p>

<p>2.extern NSString* const NSRunLoopCommonModes;
这是一个run loop mode 的合集，将input source加入之后意味着在common mode包含的所有模式下都可以处理，在Cocoa应用程序中，默认情况下Common Modes包含default modes,modal modes,event Tracking modes.注意这个并不是一个特定的mode，而是一个mode的集合，而runloop必须运行在一个特定的mode下。</p>

<p>以上两个是由NSRunloop定义的，在文档中有句话，<em>Additional run loop modes are defined by NSConnection and NSApplication</em>，增加的三个mode就是下面这三个:</p>

<p>*NSConnectionReplyMode
这个mode表明NSConnection对象等待reply，通常不会用到。</p>

<p>*NSModalPanelRunLoopMode
需要等待处理的input source为modal panel时设置，比如NSSavePanel和NSOpenPanel。</p>

<p>*NSEventTrackingRunLoopMode
Cocoa使用该模式来处理用户界面相关的事件。</p>

<p>NSRunloop并不真的是一个loop，的apple的<a href="https://developer.apple.com/library/ios/documentation/cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html">文档中</a>
也提到了需要自己写while或者for语句来实现,类似下面：</p>

<pre><code>while(running){ 
    [NSRunLoop currentRunLoop]     runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];
}
</code></pre>

<h4>何为Run loop 事件源</h4>

<p>从字面翻译来看，run loop就是一个运行循环，的确它就是一个处理输入时间的运行循环，为什么需要这样处理，难道没有事件发生的时候让线程空转浪费资源？很明显在有事件发生的时候唤醒线程，没有事件发生的时候让其sleep更好。</p>

<p>下面我还是拿这张百看不厌的图来说事：</p>

<p><img src="https://developer.apple.com/library/mac/documentation/cocoa/conceptual/Multithreading/Art/runloop.jpg" alt="alt text" /></p>

<p>可以看到，runloop处理的source大体上分为两种，一种是input source 还有一种是time source.</p>

<p>1.Time Source.
Timer sources deliver synchronous events, occurring at a scheduled time or repeating interval.</p>

<p>苹果文档中有句话需要注意，<code>Timer sources deliver events to their handler routines but do not cause the run loop to exit.</code></p>

<p>创建NSTimer添加到run loop中的时候，这里需要注意的是，NSTimer默认是处于NSDefaultRunloopMode，这也就可以解释为什么如果你在你的控制器中添加了一个timer定时刷新你的界面，而你在拖动视图的时候timer不回fire，因为这个时候你的runloop 是NSEventTrackingRunloopMode,在这个mode下timer不回fire。</p>

<p>2.input source
input source 主要是一些异步的事件，比如来自其它线程或者其它app的消息。</p>

<p>input source 传递异步事件到其对应的处理函数，并且使<code>runUntilDate</code>(与线程相关联的runloop对象调用)返回。</p>

<p>为了能够处理input sourcr，run loops 产生notifications.通过注册成run-loop observers可以接受到这些通知（通过Core Foundation 来注册observers）.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS 开发设计模式笔记（3）]]></title>
    <link href="http://billwang1990.github.io/blog/2013/12/27/12-dot-27/"/>
    <updated>2013-12-27T05:16:21-08:00</updated>
    <id>http://billwang1990.github.io/blog/2013/12/27/12-dot-27</id>
    <content type="html"><![CDATA[<p><strong>8.外观模式</strong></p>

<pre><code> 定义：为系统中的一组接口提供一个统一的接口，外观定义一个高层接口，让子系统更易于使用。

 适用情形：
 子系统正逐渐变得复杂。应用模式的过程中演化出很多类。可以适用外观为这些子系统提供一个比较简单的接口。
 可以使用外观对子系统进行分层。每个子系统级别由一个外观作为入口点。让他们通过其外观进行通信，可以简化它们的依赖关系。
</code></pre>

<!-- more -->


<p><strong>9.中介者模式</strong></p>

<pre><code> 定义：用一个对象来封装一系列对象的交互方式。中介者使各对象不需要显示地相互引用，从而使其耦合松散，而且可以独立地改变他们之间的交互。

 适用情形：
 对象间的交互虽然定义明确然而非常复杂，导致一组对象彼此相互依赖而且难以理解。
 因为对象引用了许多其他对象并与其通讯，导致对象难以复用。
 想要定制一个分布在多个类中的逻辑或行为，又不想由太多子类。

 ”迪米特法则“，如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中的一个类需要调用另一个累的某一个方法的话，可以通过第三者转发。

 说明：中介者模式以中介者内部的复杂性代替交互的复杂性，因为中介者封装与合并了colleague的各种协作逻辑，自身可能变得比他们任何一个都要复杂得多，这会让中介者本身变成无所不知的庞然大物，并且难以维护。
</code></pre>

<p><strong>10.观察者模式</strong></p>

<pre><code> 定义：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动更新。
 也称作发布——订阅模式。

 适用情形：
 有两种抽象类型相互依赖。将他们封装在各自的对象中，就可以对他们单独进行改变和复用。
 对一个对象的改变需要同时改变其他对象，但是又不知道有多少对象待改变。
 一个对象必须通知其它对象，但是又不知道其他对象是什么。
</code></pre>

<p><strong>11.组合模式</strong></p>

<pre><code> 定义：将对象组合成树形结构以表示“部分——整体”的层次结构，组合使得用户对单个对象和组合对象的使用具有一致性。

 适用情形：
 想获得对象抽象的树形表示（部分——整体层次结构）
 想让客户端统一处理组合结构中的所有对象。
</code></pre>

<p><strong>12.迭代器模式</strong></p>

<pre><code> 定义：提供一种方法访问一个聚合对象中的各个元素，而又不暴露对该对象的内部表示。

 基本上由两种类型的迭代器：外部迭代器和内部迭代器。外部迭代器让客户端直接操作迭代过程，所以客户端需要知道外部迭代器才能使用。另一种情况是，集合对象在其内部维护并操作一个外部迭代器。提供内部迭代器的典型的集合对象为客户端定义一个接口，或者从底层的集合一次访问一个元素，或者向每个元素发送消息。
 适用情形：
 需要访问组合对象的内容，而又不暴露其内部表示。。
 需要通过多种方式遍历组合对象。
 需要提供一个统一的接口，用来遍历各种类型的组合对象。
</code></pre>

<p><strong>13.访问者模式</strong></p>

<pre><code> 定义：表示一个作用于某对象结构中的各元素的操作。它让我们可以在不改变各元素的类的前提下定义作用于这些元素的新操作。

 适用情形：
 一个复杂的对象结构包含很多其他对象，他们有不同的接口，但是想对这些对象实施一些依赖于其具体类型的操作。
 需要对一个组合结构的对象进行很多不相关的操作，但是不想让这些操作”污染“这些对象的类。可以将相关的操作集中起来，定义在一个访问者类中，并在需要在访问者中定义的操作时使用它。
 定义复杂结构的类很少做修改，但是需要经常向其添加新的操作。
</code></pre>

<p><strong>14.装饰模式</strong></p>

<pre><code> 定义：动态地给一个对象添加一些额外地职责。就扩展功能来说，装饰模式相比生成子类更为灵活。

 适用情形：
 想要在不影响其他对象的情况下，以动态、透明的方式给单个对象加职责。
 想要扩展一个类的行为，却做不到。类定义可能被隐藏，无法进行子类化；或者，对类的每个行为的扩展，为支持每种功能组合，将产生大量的子类。
 对类的职责的扩展是可选的。
</code></pre>

<p><strong>15.责任链者模式</strong></p>

<pre><code> 责任链模式的主要思想是，对象引用了同一类型的另一个对象，形成一条链。链中的每个对象实现了同样的方法，处理链中第一个对象发起的同一个请求。如果一个对象不知道如何处理请求，它就把请求传给下一个响应器。

 定义：使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间发生耦合，此模式将这些对象连成一条链，并沿着这条链传递请求，知道有一个对象处理它为止。

 适用情形：
 有多个对象可以处理请求，而处理程序只有在运行时才能确定。
 向一组对象发出请求，而不想显示地指定处理请求的特定处理程序。
</code></pre>

<p><strong>16.模板方法模式</strong></p>

<pre><code> 定义：定义一个操作中算法的骨架，而将一些步骤延迟到子类中。模板方法使子类可以重定义算法的某些特定步骤而不改变算法的结构。
</code></pre>

<p><strong>17.策略模式</strong></p>

<pre><code> 定义：定义一系列算法，把他们一个个封装起来，并且使他们可相互替换。本模式使得算法可独立于使用它的客户而变化。

 适用情形：
 一个类在其操作中适用多个条件语句来定义很多行为。我们可以把相关的条件分支移动到他们自己的策略类中。
 需要算法的各种变体。
 需要避免把复杂的、与算法相关的数据结构暴露给客户端。
</code></pre>

<p><strong>18.命令模式</strong></p>

<pre><code> 定义：将请求封装为一个对象，从而可用不同的请求对客户进行参数化，对请求排队或者记录请求日志，以及支持可撤销的操作。

 适用情形：
 想让应用程序支持撤销与恢复。
 想用对象参数化一个动作以执行操作，并用不同命令对象来代替回调函数。
 想要在不同时刻对请求进行指定、排列和执行。
 想记录修改日志，这样在系统故障时，这些修改可在后来重做一遍。
 想让系统支持事务，事务封装了对数据的一系列修改。事务可以建模为命令对象。
</code></pre>

<p><strong>19.Flyweight pattern 享元模式</strong></p>

<pre><code>适用场景：
 应用程序使用很多对象
 在内存中保存对象会影响性能
 对象的多数特有状态（外在状态）可以放到外部而轻量化
 移除了外在状态后，可以用较少的共享对象替代原来那组对象
 应用程序不依赖对象标识
节省内存
</code></pre>

<p><strong>20.代理模式</strong></p>

<pre><code> 定义：为其他对象提供一种代理以控制对这个对象的访问。

 适用情形：
 需要一个远程代理，为位于不同地址空间或者网络中的对象提供本地代表。
 需要一个虚拟代理，来根据要求创建重型的对象。
 需要一个保护代理，来根据不同访问权限控制对原对象的访问。
 需要一个智能引用代理，通过对实体对象的引用进行引用技术来管理内存。也能用于锁定实体对象，让其他对象不能改变
</code></pre>

<p><strong>21.备忘录模式</strong></p>

<pre><code> 定义：在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样以后就可将该对象恢复到原先保存的状态。

 适用情形：
 需要保存一个对象（或某部分）在某一时刻的状态，这样以后就可以恢复到先前的状态。
 用于捕获状态的接口会暴露实现的细节，需要将其隐藏起来。
</code></pre>

<p>写到这里，关于iOS设计模式的笔记就差不多写完了，可能有些地方不是太对，还望大家多多指点，给我发<a href="billwang1990@gmail.com">gmail</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MAC下安装Octopress，Cocoapods关于ruby版本的问题]]></title>
    <link href="http://billwang1990.github.io/blog/2013/12/25/3-number-post/"/>
    <updated>2013-12-25T14:01:54-08:00</updated>
    <id>http://billwang1990.github.io/blog/2013/12/25/3-number-post</id>
    <content type="html"><![CDATA[<p>不多说，直接上正题。
系统是10.8.4的，没升级，黑苹果不敢升级，每次升级会很麻烦！</p>

<p>因为开发iOS，所以需要使用cocoapods来管理三方, 另外需要搭建一个Octopress的blog，两者都需要用到ruby，问题来了：</p>

<p>Octopress要求ruby的版本不低于 1.9.3，而系统自带的ruby是1.8.7的，很明显不搭调，于是使用 <strong>rvm install 1.9.3</strong> 安装ruby。 然后照<a href="http://octopress.org/docs/setup/">Octopress官方安装教程</a>配置。</p>

<!-- more -->


<p>OK，Octopress一切完工，这个时候我来安装cocoapods，它也用到了ruby，这个时候默认的ruby已经不是系统自带的ruby了。于是在使用 <strong>$sudo gem install cocoapods</strong> 安装的时候一直报错 ：COreFoundation is needed to build the Xcodeproj C extension.</p>

<p>找了很多解决办法，比如重新安装xcode command line tools，使用xcode-selelct等等，都不起作用。好吧，最后还是去cocoapods看看，开发者强烈建议使用Mac自带的ruby来安装cocoapods。</p>

<p>好吧，最后我妥协了，将默认的ruby还原为系统自带的ruby，这个时候再来安装cocoapods，一切正常. 然后只是将octopress的工作目录使用rvm配置为使用1.9.3的ruby，也就是说使用了两个版本的ruby。</p>

<p>方法虽然看起来是土了一点，但是简单粗暴有效！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS 开发设计模式笔记（2）]]></title>
    <link href="http://billwang1990.github.io/blog/2013/12/24/2nd-blog/"/>
    <updated>2013-12-24T16:36:33-08:00</updated>
    <id>http://billwang1990.github.io/blog/2013/12/24/2nd-blog</id>
    <content type="html"><![CDATA[<p>这篇是接着<a href="http://billwang1990.github.io/blog/2013/12/25/1st-blog/">上一篇</a></p>

<h4>4.生成器模式</h4>

<pre><code> 定义：
 将一个复杂对象的构建与它的表现分离，使得同样的构建过程可以创建不同的表现。
 适用情景：
 需要创建涉及各种部件的复杂对象。创建对象的算法应该独立于部件的装配方式。常见例子是构建组合对象。
 构建过程需要以不同的方式构建对象。
 将做什么 和 怎么做 两个问题分开解决。
</code></pre>

<!-- more -->


<h4>5.单例模式</h4>

<pre><code> 定义:保证一个类仅有一个实例，并且提供一个访问它的全局访问点。
 适用情形:
 类只能有一个实例，而且必须从一个为人熟知的访问点对其进行访问，比如工厂方法。
 这个唯一的实例只能通过子类化进行扩展，而且扩展的对象不会破坏客户端代码。
</code></pre>

<h4>6.适配器模式</h4>

<pre><code> 适配器模式，用于连接两种不同种类的对象，使其毫无问题地协同工作，有时它也称为包装起"wrapper"。
 基本上有两种实现适配器的方式:
 1.通过集成来适配来适配两个接口，这种称为类适配器，多通过多重继承来实现，但是OBJ-C没有多重继承，可以通过协议来实现。
 2.对象适配器。与类适配器不同，对象适配器不继承被适配者，而是组合一个对它的引用。
 定义：
 将一个类的接口转换成客户希望的另一个接口，适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。
 适用情形：
 已有的类的接口和需求不匹配。
 想要一个可复用的类，该类能够同可能带有不兼容接口的其它类协作。
 需要适配一个类的几个不同子类，可是让每一个子类去子类化一个类适配器又不现实。那么可以通过使用对象适配器（也叫委托）来适配其父类的接口。
</code></pre>

<h4>7.桥接模式</h4>

<pre><code> 定义：将抽象部分与它的实现部分分离，使它们都可以独立的变化。
 适用情形：
 不想在抽象与其实现之间实现固定的绑定关系。
 抽象及其实现都应该可以通过子类化独立进行扩展。
 对抽象的实现进行修改不应该影响客户端的代码。
 如果每个实现需要额外的子类以细化抽象，择说明有必要把他们分成两个部分。
 想在带有不同抽象接口的多个对象之间共享一个实现。
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS 开发设计模式笔记（1）]]></title>
    <link href="http://billwang1990.github.io/blog/2013/12/24/1st-blog/"/>
    <updated>2013-12-24T15:52:44-08:00</updated>
    <id>http://billwang1990.github.io/blog/2013/12/24/1st-blog</id>
    <content type="html"><![CDATA[<h4>读了《OBJECTIVE－C编程之道 IOS设计模式解析》，觉得有些东西有必要记录下来,因此有了以下的笔记:</h4>

<h4>1.Prototype 原型模式</h4>

<pre><code>定义：使用原型实例指定创建对象的种类，并通过复制这个原型创建新的对象。（《设计模式》1994）
</code></pre>

<!-- more -->


<pre><code> 一般在初始化信息不发生变化的情况下，克隆是最好的办法。这既可以隐藏对象创建的细节，又对性能是大大的提升。
 适用情景：
 需要创建的对象应独立于其类型与创建方式。
 要实例化的类是运行时决定的。
 不想要与产品层次相对应的工厂层次。
 不同类的实例间的差异仅是状态的若干组合。因此复制相应数量的原型比手工实例化更加方便。
 类不容易创建，比如每个组件可把其他组件作为子节点的组合对象。复制已有的组合对象并对副本进行修改会更加容易。
</code></pre>

<h4>2.工厂方法模式</h4>

<pre><code> 工厂方法也称为虚构造器。它适用于这种情况：一个类无法预期需要生成哪个类的对象，想让其子类来指定所生成的对象。
 定义：定义创建对对象的接口，让子类决定实例化哪一个类，工厂方法使得一个类的实例化延迟到子类。
 适用情形：
 编译时无法准确预期要创建的对象的类。
 类想让其子类决定在运行时创建什么
 类由若干辅助类为其子类，而你想将返回哪个子类这一信息局部化
</code></pre>

<h4>3.抽象工厂</h4>

<pre><code>定义：提供一个创建一系列相关或相互依赖对象的接口，而无需指定他们具体的类。
 软件设计黄金法则：变动需要抽象。
 比如，如果APP要支持更换皮肤，可以设计成抽象工厂。
</code></pre>
]]></content>
  </entry>
  
</feed>
