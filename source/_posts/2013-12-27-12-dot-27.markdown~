---
layout: post
title: "12.27"
date: 2013-12-27 21:16:21 +0800
comments: true
categories: 
---


**8.外观模式**
    
     定义：为系统中的一组接口提供一个统一的接口，外观定义一个高层接口，让子系统更易于使用。

     适用情形：
     子系统正逐渐变得复杂。应用模式的过程中演化出很多类。可以适用外观为这些子系统提供一个比较简单的接口。
     可以使用外观对子系统进行分层。每个子系统级别由一个外观作为入口点。让他们通过其外观进行通信，可以简化它们的依赖关系。

<!-- more -->

**9.中介者模式**

     定义：用一个对象来封装一系列对象的交互方式。中介者使各对象不需要显示地相互引用，从而使其耦合松散，而且可以独立地改变他们之间的交互。
     
     适用情形：
     对象间的交互虽然定义明确然而非常复杂，导致一组对象彼此相互依赖而且难以理解。
     因为对象引用了许多其他对象并与其通讯，导致对象难以复用。
     想要定制一个分布在多个类中的逻辑或行为，又不想由太多子类。

     ”迪米特法则“，如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中的一个类需要调用另一个累的某一个方法的话，可以通过第三者转发。

     说明：中介者模式以中介者内部的复杂性代替交互的复杂性，因为中介者封装与合并了colleague的各种协作逻辑，自身可能变得比他们任何一个都要复杂得多，这会让中介者本身变成无所不知的庞然大物，并且难以维护。


**10.观察者模式**

     定义：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动更新。
     也称作发布——订阅模式。

     适用情形：
     有两种抽象类型相互依赖。将他们封装在各自的对象中，就可以对他们单独进行改变和复用。
     对一个对象的改变需要同时改变其他对象，但是又不知道有多少对象待改变。
     一个对象必须通知其它对象，但是又不知道其他对象是什么。

**11.组合模式**

     定义：将对象组合成树形结构以表示“部分——整体”的层次结构，组合使得用户对单个对象和组合对象的使用具有一致性。

     适用情形：
     想获得对象抽象的树形表示（部分——整体层次结构）
     想让客户端统一处理组合结构中的所有对象。

     
**12.迭代器模式**

     定义：提供一种方法访问一个聚合对象中的各个元素，而又不暴露对该对象的内部表示。

     基本上由两种类型的迭代器：外部迭代器和内部迭代器。外部迭代器让客户端直接操作迭代过程，所以客户端需要知道外部迭代器才能使用。另一种情况是，集合对象在其内部维护并操作一个外部迭代器。提供内部迭代器的典型的集合对象为客户端定义一个接口，或者从底层的集合一次访问一个元素，或者向每个元素发送消息。
     适用情形：
     需要访问组合对象的内容，而又不暴露其内部表示。。
     需要通过多种方式遍历组合对象。
     需要提供一个统一的接口，用来遍历各种类型的组合对象。

**13.访问者模式**
     
     定义：表示一个作用于某对象结构中的各元素的操作。它让我们可以在不改变各元素的类的前提下定义作用于这些元素的新操作。

     适用情形：
     一个复杂的对象结构包含很多其他对象，他们有不同的接口，但是想对这些对象实施一些依赖于其具体类型的操作。
     需要对一个组合结构的对象进行很多不相关的操作，但是不想让这些操作”污染“这些对象的类。可以将相关的操作集中起来，定义在一个访问者类中，并在需要在访问者中定义的操作时使用它。
     定义复杂结构的类很少做修改，但是需要经常向其添加新的操作。


**14.装饰模式**

     定义：动态地给一个对象添加一些额外地职责。就扩展功能来说，装饰模式相比生成子类更为灵活。

     适用情形：
     想要在不影响其他对象的情况下，以动态、透明的方式给单个对象加职责。
     想要扩展一个类的行为，却做不到。类定义可能被隐藏，无法进行子类化；或者，对类的每个行为的扩展，为支持每种功能组合，将产生大量的子类。
     对类的职责的扩展是可选的。

**15.责任链者模式**

     责任链模式的主要思想是，对象引用了同一类型的另一个对象，形成一条链。链中的每个对象实现了同样的方法，处理链中第一个对象发起的同一个请求。如果一个对象不知道如何处理请求，它就把请求传给下一个响应器。

     定义：使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间发生耦合，此模式将这些对象连成一条链，并沿着这条链传递请求，知道有一个对象处理它为止。

     适用情形：
     有多个对象可以处理请求，而处理程序只有在运行时才能确定。
     向一组对象发出请求，而不想显示地指定处理请求的特定处理程序。

**16.模板方法模式**

     定义：定义一个操作中算法的骨架，而将一些步骤延迟到子类中。模板方法使子类可以重定义算法的某些特定步骤而不改变算法的结构。

**17.策略模式**

     定义：定义一系列算法，把他们一个个封装起来，并且使他们可相互替换。本模式使得算法可独立于使用它的客户而变化。

     适用情形：
     一个类在其操作中适用多个条件语句来定义很多行为。我们可以把相关的条件分支移动到他们自己的策略类中。
     需要算法的各种变体。
     需要避免把复杂的、与算法相关的数据结构暴露给客户端。

**18.命令模式**

     定义：将请求封装为一个对象，从而可用不同的请求对客户进行参数化，对请求排队或者记录请求日志，以及支持可撤销的操作。

     适用情形：
     想让应用程序支持撤销与恢复。
     想用对象参数化一个动作以执行操作，并用不同命令对象来代替回调函数。
     想要在不同时刻对请求进行指定、排列和执行。
     想记录修改日志，这样在系统故障时，这些修改可在后来重做一遍。
     想让系统支持事务，事务封装了对数据的一系列修改。事务可以建模为命令对象。


**19.Flyweight pattern 享元模式**

    适用场景：
     应用程序使用很多对象
     在内存中保存对象会影响性能
     对象的多数特有状态（外在状态）可以放到外部而轻量化
     移除了外在状态后，可以用较少的共享对象替代原来那组对象
     应用程序不依赖对象标识
    节省内存
     
    
**20.代理模式**

     定义：为其他对象提供一种代理以控制对这个对象的访问。

     适用情形：
     需要一个远程代理，为位于不同地址空间或者网络中的对象提供本地代表。
     需要一个虚拟代理，来根据要求创建重型的对象。
     需要一个保护代理，来根据不同访问权限控制对原对象的访问。
     需要一个智能引用代理，通过对实体对象的引用进行引用技术来管理内存。也能用于锁定实体对象，让其他对象不能改变

**21.备忘录模式**
     
     定义：在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样以后就可将该对象恢复到原先保存的状态。

     适用情形：
     需要保存一个对象（或某部分）在某一时刻的状态，这样以后就可以恢复到先前的状态。
     用于捕获状态的接口会暴露实现的细节，需要将其隐藏起来。


写到这里，关于iOS设计模式的笔记就差不多写完了，可能有些地方不是太对，还望大家多多指点，给我发[gmail](billwang1990@gmail.com).

